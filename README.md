#### 获取Class类的三种方式
- 使用Class.forName()静态方法
- 使用类的class属性
- 使用实例对象的getClass()方法
### SSM
#### 1、Spring
#### 1.1 请问声明是IOC和DI？并简要说明一下DI是如何实现的
IOC叫控制反转，DI叫依赖注入。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。"控制反转"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，即由容器动态的将某种依赖关系注入到组件之中。
依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。
- 依赖注入是从应用程序的角度在描述：应用程序依赖容器创建并注入它所需要的外部资源；
- 控制反转是从容器的角度在描述：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。
#### 1.2 请问AOP的原理是什么？
AOP指面向切面编程，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常使用AspectJ的编译时增强实现AOP，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。
Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。
- JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。核心是InvocationHandler接口和Proxy类。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。
- CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类



